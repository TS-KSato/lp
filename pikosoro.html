<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="theme-color" content="#1a1a2e">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>ピコそろ - 指先で感じる計算の美学</title>
  
  <style>
    /* リセット & 基本設定 */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }

    :root {
      --primary-bg: #0a0a0f;
      --secondary-bg: #1a1a2e;
      --accent-gold: #ffd700;
      --accent-red: #ff4757;
      --text-primary: #ffffff;
      --text-secondary: #b8b8b8;
      --safe-area-top: env(safe-area-inset-top);
      --safe-area-bottom: env(safe-area-inset-bottom);
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', 'Hiragino Sans', sans-serif;
      background: var(--primary-bg);
      color: var(--text-primary);
      height: 100vh; /* For older browsers */
      height: calc(var(--vh, 1vh) * 100); /* Dynamic viewport height */
      overflow: hidden;
      position: fixed;
      width: 100%;
      user-select: none;
      -webkit-font-smoothing: antialiased;
    }

    /* スキップリンク（アクセシビリティ） */
    .skip-link {
      position: absolute;
      top: -40px;
      left: 0;
      background: var(--accent-gold);
      color: var(--primary-bg);
      padding: 8px;
      text-decoration: none;
      border-radius: 0 0 8px 0;
      z-index: 9999;
    }

    .skip-link:focus {
      top: 0;
    }

    /* ローディング画面 */
    .loading-screen {
      position: fixed;
      inset: 0;
      background: var(--primary-bg);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 9998;
      transition: opacity 0.5s ease;
    }

    .loading-screen.hidden {
      opacity: 0;
      pointer-events: none;
    }

    .loading-spinner {
      width: 60px;
      height: 60px;
      border: 3px solid rgba(255, 215, 0, 0.3);
      border-top-color: var(--accent-gold);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* メインコンテナ */
    .app-container {
      height: 100%; /* Changed from 100vh to use dynamic --vh */
      display: flex;
      flex-direction: column;
      padding-top: var(--safe-area-top);
      position: relative;
      background: radial-gradient(ellipse at top, #1a1a2e 0%, #0a0a0f 100%);
    }

    /* ヘッダー */
    .app-header {
      padding: 16px 20px;
      text-align: center;
      position: relative;
      z-index: 10;
    }

    .app-title {
      font-size: 1.5rem;
      font-weight: 700;
      background: linear-gradient(135deg, var(--accent-gold), #ff6b6b);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      letter-spacing: 0.05em;
    }

    /* 算盤セクション（上部） */
    .abacus-section {
      flex: 1;
      padding: 20px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      position: relative;
      overflow: hidden;
    }

    .abacus-container {
      background: rgba(255, 255, 255, 0.03);
      backdrop-filter: blur(20px);
      border-radius: 24px;
      padding: 20px;
      box-shadow: 
        0 10px 40px rgba(0, 0, 0, 0.3),
        inset 0 1px 1px rgba(255, 255, 255, 0.1);
      transform-style: preserve-3d;
      perspective: 1000px;
    }

    .abacus-frame {
      position: relative;
      height: 280px;
      margin: 0 auto;
      max-width: 360px;
    }

    .abacus-rods {
      display: flex;
      justify-content: space-evenly;
      height: 100%;
      position: relative;
    }

    .abacus-rod {
      width: 60px;
      position: relative;
      transform-style: preserve-3d;
    }

    .rod-pillar {
      position: absolute;
      width: 6px;
      height: 100%;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(to right, #4a4a4a, #6a6a6a, #4a4a4a);
      border-radius: 3px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
    }

    .abacus-divider {
      position: absolute;
      width: 100%;
      height: 6px;
      background: linear-gradient(to bottom, #8b6914, #654321);
      top: 30%; /* This defines the separation line */
      left: 0;
      z-index: 5;
      border-radius: 3px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
    }

    .abacus-bead {
      position: absolute;
      width: 50px;
      height: 35px;
      left: 50%;
      transform: translateX(-50%);
      border-radius: 50%;
      cursor: pointer;
      transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
      transform-style: preserve-3d;
    }

    .abacus-bead::before {
      content: '';
      position: absolute;
      inset: 0;
      border-radius: 50%;
      background: radial-gradient(ellipse at 30% 30%, 
        rgba(255, 255, 255, 0.8), 
        rgba(255, 215, 0, 0.8) 30%, 
        rgba(184, 134, 11, 0.9) 80%);
      box-shadow: 
        inset -5px -5px 10px rgba(0, 0, 0, 0.3),
        inset 5px 5px 10px rgba(255, 255, 255, 0.3),
        0 8px 16px rgba(0, 0, 0, 0.4);
    }

    .abacus-bead.heaven {
      /* Initial position above divider */
      top: 15%; 
    }

    .abacus-bead.heaven.active {
      /* Moved down, towards/past divider */
      transform: translateX(-50%) translateY(60px); 
    }

    /* --- MODIFIED CSS for Earth Beads --- */
    /* Default initial position for earth beads (below divider) */
    /* This default is not strictly needed if all data-index are styled */
    /* .abacus-bead.earth { bottom: 15%; } */

    /* data-index="0" is the earth bead closest to the divider (top-most earth bead) */
    /* data-index="3" is the earth bead furthest from the divider (bottom-most earth bead) */
    .abacus-bead.earth[data-index="0"] { bottom: 54%; } /* Initial position for index 0 */
    .abacus-bead.earth[data-index="1"] { bottom: 41%; } /* Initial position for index 1 */
    .abacus-bead.earth[data-index="2"] { bottom: 28%; } /* Initial position for index 2 */
    .abacus-bead.earth[data-index="3"] { bottom: 15%; } /* Initial position for index 3 */
    /* --- END OF MODIFIED CSS --- */
    
    .abacus-bead.earth.active {
      /* Moved up, towards/past divider */
      transform: translateX(-50%) translateY(-60px); /* Adjusted Y translation for earth beads */
    }

    .abacus-bead.moving {
      animation: bead-bounce 0.5s ease;
    }

    @keyframes bead-bounce {
      0%, 100% { transform: translateX(-50%) scale(1); }
      50% { transform: translateX(-50%) scale(1.1); }
    }
    
    /* Ensure active beads maintain their transform when bouncing */
    .abacus-bead.heaven.active.moving {
        animation: bead-bounce-heaven-active 0.5s ease;
    }
    @keyframes bead-bounce-heaven-active {
      0%, 100% { transform: translateX(-50%) translateY(60px) scale(1); }
      50% { transform: translateX(-50%) translateY(60px) scale(1.1); }
    }
    .abacus-bead.earth.active.moving {
        animation: bead-bounce-earth-active 0.5s ease;
    }
    @keyframes bead-bounce-earth-active {
      0%, 100% { transform: translateX(-50%) translateY(-60px) scale(1); }
      50% { transform: translateX(-50%) translateY(-60px) scale(1.1); }
    }


    .digit-label {
      position: absolute;
      bottom: -35px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.875rem;
      color: var(--text-secondary);
      font-weight: 500;
    }

    /* 計算結果表示 */
    .result-display {
      background: rgba(0, 0, 0, 0.6);
      border-radius: 16px;
      padding: 16px 24px;
      margin: 20px;
      text-align: right;
      font-family: 'SF Mono', 'Monaco', monospace;
      font-size: 2rem;
      color: var(--accent-gold);
      min-height: 60px;
      display: flex;
      align-items: center;
      justify-content: flex-end;
      box-shadow: 
        inset 0 2px 8px rgba(0, 0, 0, 0.8),
        0 1px 1px rgba(255, 255, 255, 0.1);
      position: relative;
      overflow: hidden;
      word-break: break-all; /* For "Error" message */
    }

    .result-display::before {
      content: '';
      position: absolute;
      top: -2px;
      left: -2px;
      right: -2px;
      bottom: -2px;
      background: linear-gradient(45deg, transparent, var(--accent-gold), transparent);
      opacity: 0;
      z-index: -1;
      transition: opacity 0.3s ease;
    }

    .result-display.calculating::before {
      opacity: 0.3;
      animation: glow-sweep 1s linear infinite;
    }

    @keyframes glow-sweep {
      to { transform: translateX(100%); }
    }

    /* 電卓セクション（下部） */
    .calculator-section {
      background: rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(20px);
      border-radius: 32px 32px 0 0;
      padding: 24px 20px calc(var(--safe-area-bottom) + 20px);
      box-shadow: 0 -10px 30px rgba(0, 0, 0, 0.3);
    }

    .calculator-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 12px;
      max-width: 400px;
      margin: 0 auto;
    }

    .calc-button {
      aspect-ratio: 1;
      border: none;
      border-radius: 20px;
      font-size: 1.5rem;
      font-weight: 600;
      color: var(--text-primary);
      background: rgba(255, 255, 255, 0.08);
      backdrop-filter: blur(10px);
      cursor: pointer;
      position: relative;
      overflow: hidden;
      transition: all 0.2s ease;
      min-height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .calc-button::before {
      content: '';
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at center, transparent, rgba(255, 255, 255, 0.1));
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .calc-button:active {
      transform: scale(0.95);
    }

    .calc-button:active::before {
      opacity: 1;
    }

    .calc-button.operator {
      background: rgba(255, 107, 107, 0.2);
      color: #ff6b6b;
    }

    .calc-button.equals {
      background: linear-gradient(135deg, var(--accent-gold), #ff6b6b);
      grid-column: span 2;
      color: var(--primary-bg);
      font-weight: 700;
    }

    .calc-button.clear {
      background: rgba(52, 152, 219, 0.2);
      color: #3498db;
    }

    /* 振動フィードバック用クラス */
    .vibrate {
      animation: vibrate 0.1s linear;
    }

    @keyframes vibrate {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-1px); }
      75% { transform: translateX(1px); }
    }

    /* パーティクル効果 */
    .particle {
      position: absolute;
      width: 4px;
      height: 4px;
      background: var(--accent-gold);
      border-radius: 50%;
      pointer-events: none;
      animation: particle-float 1s ease-out forwards;
    }

    @keyframes particle-float {
      0% {
        opacity: 1;
        transform: translate(0, 0) scale(1);
      }
      100% {
        opacity: 0;
        transform: translate(var(--tx), var(--ty)) scale(0);
      }
    }

    /* チュートリアルオーバーレイ */
    .tutorial-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.9);
      z-index: 1000;
      display: none; /* Initially hidden */
      justify-content: center;
      align-items: center;
      padding: 20px;
    }

    .tutorial-overlay.active {
      display: flex; /* Show when active */
    }

    .tutorial-content {
      background: var(--secondary-bg);
      border-radius: 24px;
      padding: 32px 24px;
      max-width: 320px;
      text-align: center;
      animation: slideUp 0.3s ease;
    }

    @keyframes slideUp {
      from {
        opacity: 0;
        transform: translateY(20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .tutorial-title {
      font-size: 1.5rem;
      font-weight: 700;
      color: var(--accent-gold);
      margin-bottom: 16px;
    }

    .tutorial-text {
      color: var(--text-secondary);
      line-height: 1.6;
      margin-bottom: 24px;
    }

    .tutorial-button {
      background: linear-gradient(135deg, var(--accent-gold), #ff6b6b);
      color: var(--primary-bg);
      border: none;
      border-radius: 16px;
      padding: 14px 32px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.2s ease;
    }

    .tutorial-button:active {
      transform: scale(0.95);
    }

    /* アクセシビリティ：フォーカス表示 */
    *:focus-visible { /* Changed from :focus to :focus-visible for better UX */
      outline: 3px solid var(--accent-gold);
      outline-offset: 2px;
    }

    /* アクセシビリティ：高コントラストモード */
    @media (prefers-contrast: high) {
      :root {
        --primary-bg: #000000;
        --secondary-bg: #1a1a1a;
        --text-primary: #ffffff;
        --text-secondary: #e0e0e0;
      }
      
      .calc-button {
        border: 2px solid var(--text-primary);
      }
    }

    /* アクセシビリティ：モーション低減 */
    @media (prefers-reduced-motion: reduce) {
      * {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
        scroll-behavior: auto !important;
      }
    }

    /* 横向き対応 */
    @media (orientation: landscape) and (max-height: 500px) {
      .app-header {
        padding: 8px 20px;
      }
      
      .app-title {
        font-size: 1.2rem;
      }
      
      .abacus-section {
        padding: 10px;
      }
      
      .abacus-frame {
        height: 200px; /* Adjust abacus height for landscape */
      }
       /* Adjust bead movement for smaller abacus */
      .abacus-bead.heaven.active { transform: translateX(-50%) translateY(40px); }
      .abacus-bead.earth.active { transform: translateX(-50%) translateY(-40px); }


      .calculator-section {
        padding: 16px 20px;
      }
      
      .calc-button {
        min-height: 48px;
        font-size: 1.2rem;
      }
    }

    /* アニメーション設定パネル */
    .settings-panel {
      position: fixed;
      top: 60px; /* Adjust based on header/safe area */
      right: 20px;
      background: rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(20px);
      border-radius: 16px;
      padding: 16px;
      transform: translateX(120%);
      transition: transform 0.3s ease;
      z-index: 100;
    }

    .settings-panel.active {
      transform: translateX(0);
    }

    .settings-button {
      position: fixed;
      top: 16px; /* Adjusted for consistency with safe-area */
      right: 20px;
      width: 44px;
      height: 44px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.1);
      border: none;
      color: var(--text-primary);
      font-size: 1.5rem;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 101; /* Ensure above settings panel when closed */
    }
     /* Ensure settings panel is below button when transitioning */
    .settings-panel { z-index: 100; }


    /* PWAインストールプロンプト */
    .install-prompt {
      position: fixed;
      bottom: calc(var(--safe-area-bottom) + 80px);
      left: 20px;
      right: 20px;
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(20px);
      border-radius: 16px;
      padding: 16px;
      display: none; /* Initially hidden */
      animation: slideUp 0.3s ease;
      z-index: 90;
    }

    .install-prompt.show {
      display: block; /* Show when class is added */
    }

    /* サウンドインジケーター */
    .sound-indicator {
      position: fixed;
      top: 16px; /* Adjusted for consistency */
      left: 20px;
      width: 44px;
      height: 44px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.1);
      border: none;
      color: var(--text-primary);
      font-size: 1.2rem;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 101;
    }

    .sound-indicator.muted {
      color: var(--text-secondary);
    }

  </style>
</head>
<body>
  <!-- スキップリンク -->
  <a href="#calculator" class="skip-link">電卓へスキップ</a>

  <!-- ローディング画面 -->
  <div class="loading-screen" role="status" aria-live="assertive" aria-label="読み込み中">
    <div class="loading-spinner"></div>
  </div>

  <!-- メインアプリ -->
  <main class="app-container" role="main">
    <!-- ヘッダー -->
    <header class="app-header" role="banner">
      <h1 class="app-title">ピコそろ電卓</h1> <!-- Title slightly adjusted for branding -->
    </header>

    <!-- サウンドインジケーター -->
    <button class="sound-indicator" id="soundToggle" aria-label="サウンドのオン・オフ" aria-pressed="true">
      <span aria-hidden="true">🔊</span>
    </button>

    <!-- 設定ボタン -->
    <button class="settings-button" id="settingsButton" aria-label="設定を開く" aria-expanded="false" aria-controls="settingsPanel">
      <span aria-hidden="true">⚙️</span>
    </button>

    <!-- 設定パネル -->
    <aside class="settings-panel" id="settingsPanel" role="complementary" aria-label="設定" hidden>
      <h2 style="font-size: 1rem; margin-bottom: 12px;" id="settingsPanelTitle">設定</h2>
      <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
        <input type="checkbox" id="hapticToggle" checked>
        <span>振動フィードバック</span>
      </label>
      <label style="display: flex; align-items: center; gap: 8px;">
        <input type="checkbox" id="particleToggle" checked>
        <span>パーティクル効果</span>
      </label>
    </aside>

    <!-- 算盤セクション -->
    <section class="abacus-section" aria-label="算盤">
      <div class="abacus-container">
        <div class="abacus-frame" role="img" aria-label="5桁の算盤">
          <div class="abacus-rods" id="abacusRods">
            <!-- Divider is part of the frame, not dynamically added to rods -->
            <div class="abacus-divider" aria-hidden="true"></div>
          </div>
        </div>
      </div>
      
      <!-- 計算結果表示 -->
      <div class="result-display" id="display" role="status" aria-live="polite" aria-atomic="true">
        0
      </div>
    </section>

    <!-- 電卓セクション -->
    <section class="calculator-section" id="calculator" aria-label="電卓">
      <div class="calculator-grid">
        <button class="calc-button clear" data-action="clear" aria-label="クリア">C</button>
        <button class="calc-button operator" data-action="backspace" aria-label="バックスペース">BS</button> <!-- Added Backspace -->
        <button class="calc-button operator" data-action="percent" aria-label="パーセント">%</button> <!-- Added Percent -->
        <button class="calc-button operator" data-action="operator" data-value="÷" aria-label="割る">÷</button>
        
        <button class="calc-button" data-action="number" data-value="7" aria-label="7">7</button>
        <button class="calc-button" data-action="number" data-value="8" aria-label="8">8</button>
        <button class="calc-button" data-action="number" data-value="9" aria-label="9">9</button>
        <button class="calc-button operator" data-action="operator" data-value="×" aria-label="掛ける">×</button>

        <button class="calc-button" data-action="number" data-value="4" aria-label="4">4</button>
        <button class="calc-button" data-action="number" data-value="5" aria-label="5">5</button>
        <button class="calc-button" data-action="number" data-value="6" aria-label="6">6</button>
        <button class="calc-button operator" data-action="operator" data-value="-" aria-label="引く">-</button>

        <button class="calc-button" data-action="number" data-value="1" aria-label="1">1</button>
        <button class="calc-button" data-action="number" data-value="2" aria-label="2">2</button>
        <button class="calc-button" data-action="number" data-value="3" aria-label="3">3</button>
        <button class="calc-button operator" data-action="operator" data-value="+" aria-label="足す">+</button>
        
        <button class="calc-button" data-action="number" data-value="0" aria-label="0" style="grid-column: span 2;">0</button> <!-- Zero button spans 2 columns -->
        <button class="calc-button" data-action="decimal" data-value="." aria-label="小数点">.</button> <!-- Added Decimal -->
        <button class="calc-button equals" data-action="equals" aria-label="イコール">=</button>
      </div>
    </section>
  </main>

  <!-- チュートリアルオーバーレイ -->
  <div class="tutorial-overlay" id="tutorialOverlay" role="dialog" aria-modal="true" aria-labelledby="tutorialTitle" aria-describedby="tutorialText" hidden>
    <div class="tutorial-content">
      <h2 class="tutorial-title" id="tutorialTitle">ようこそ！</h2>
      <p class="tutorial-text" id="tutorialText">
        電卓で計算すると、上の算盤が連動して動きます。<br>
        珠をタップして直接動かすこともできます。
      </p>
      <button class="tutorial-button" id="tutorialClose">はじめる</button>
    </div>
  </div>

  <!-- PWAインストールプロンプト -->
  <div class="install-prompt" id="installPrompt" role="alert" hidden>
    <p style="margin-bottom: 12px;">ホーム画面に追加して、いつでもすぐに使えるようにしましょう！</p>
    <button class="tutorial-button" id="installButton" style="width: 100%;">インストール</button>
  </div>

  <script>
    // グローバル変数
    const state = {
      displayValue: '0',
      firstOperand: null,
      waitingForOperand: false,
      operator: null,
      soundEnabled: true,
      hapticEnabled: true,
      particleEnabled: true,
      errorState: false, // Added error state
    };

    // オーディオコンテキスト（サウンド用）
    let audioContext = null;

    // DOM要素
    const display = document.getElementById('display');
    const abacusRodsContainer = document.getElementById('abacusRods'); // Renamed for clarity
    const buttons = document.querySelectorAll('.calc-button');
    const loadingScreen = document.querySelector('.loading-screen');
    const tutorialOverlay = document.getElementById('tutorialOverlay');
    const tutorialClose = document.getElementById('tutorialClose');
    const soundToggle = document.getElementById('soundToggle');
    const settingsButton = document.getElementById('settingsButton');
    const settingsPanel = document.getElementById('settingsPanel');
    const hapticToggle = document.getElementById('hapticToggle');
    const particleToggle = document.getElementById('particleToggle');
    const installPromptEl = document.getElementById('installPrompt'); // Renamed to avoid conflict
    const installButton = document.getElementById('installButton');

    // PWA用変数
    let deferredPrompt;
    const MAX_DIGITS = 5; // Max digits for abacus positive numbers
    const MAX_INPUT_LENGTH = MAX_DIGITS + 1; // For negative sign e.g. -9999 is 5 chars, 99999 is 5 chars

    // 初期化
    function init() {
      // Set dynamic viewport height
      const setVh = () => {
        const vh = window.innerHeight * 0.01;
        document.documentElement.style.setProperty('--vh', `${vh}px`);
      };
      window.addEventListener('resize', setVh);
      setVh(); // Initial call

      initializeAbacus();
      initializeEventListeners();
      initializeAudio(); // Attempt to initialize early
      checkFirstVisit();
      initializePWA();
      updateDisplay(); // Initial display update
      
      setTimeout(() => {
        loadingScreen.classList.add('hidden');
        loadingScreen.setAttribute('aria-hidden', 'true'); // Hide from AT
      }, 500);
    }

    // 算盤の初期化
    function initializeAbacus() {
      const positions = ['万', '千', '百', '十', '一']; // Corresponds to 10^4, 10^3, ..., 10^0
      
      for (let i = 0; i < MAX_DIGITS; i++) { // Rods from left (万) to right (一)
        const rod = document.createElement('div');
        rod.className = 'abacus-rod';
        rod.setAttribute('data-position-index', i); // 0 for 万, 1 for 千, ..., 4 for 一
        rod.setAttribute('aria-label', `${positions[i]}の位`);

        const pillar = document.createElement('div');
        pillar.className = 'rod-pillar';
        pillar.setAttribute('aria-hidden', 'true');
        rod.appendChild(pillar);

        const heavenBead = document.createElement('button');
        heavenBead.className = 'abacus-bead heaven';
        heavenBead.setAttribute('data-value', '5');
        heavenBead.setAttribute('data-position-index', i);
        heavenBead.setAttribute('role', 'button');
        heavenBead.setAttribute('aria-label', `${positions[i]}の位の5の珠`);
        heavenBead.setAttribute('aria-pressed', 'false');
        heavenBead.addEventListener('click', handleBeadClick);
        rod.appendChild(heavenBead);

        for (let j = 0; j < 4; j++) { // Earth beads, j=0 is top-most, j=3 is bottom-most
          const earthBead = document.createElement('button');
          earthBead.className = 'abacus-bead earth';
          earthBead.setAttribute('data-value', '1');
          earthBead.setAttribute('data-position-index', i);
          earthBead.setAttribute('data-index', j); // j=0 (top) to j=3 (bottom)
          earthBead.setAttribute('role', 'button');
          earthBead.setAttribute('aria-label', `${positions[i]}の位の${j + 1}番目の1の珠 (上から${j+1}番目)`);
          earthBead.setAttribute('aria-pressed', 'false');
          earthBead.addEventListener('click', handleBeadClick);
          rod.appendChild(earthBead);
        }

        const label = document.createElement('div');
        label.className = 'digit-label';
        label.textContent = positions[i];
        label.setAttribute('aria-hidden', 'true');
        rod.appendChild(label);

        abacusRodsContainer.appendChild(rod);
      }
    }

    // イベントリスナーの初期化
    function initializeEventListeners() {
      buttons.forEach(button => {
        button.addEventListener('click', handleButtonClick);
      });
      document.addEventListener('keydown', handleKeyPress);
      tutorialClose.addEventListener('click', closeTutorial);
      soundToggle.addEventListener('click', toggleSound);
      settingsButton.addEventListener('click', toggleSettings);
      hapticToggle.addEventListener('change', (e) => state.hapticEnabled = e.target.checked);
      particleToggle.addEventListener('change', (e) => state.particleEnabled = e.target.checked);
      installButton.addEventListener('click', installPWA);
    }

    // オーディオ初期化 (ユーザーインタラクション後に呼び出されることを推奨)
    function initializeAudio() {
      if (audioContext) return;
      try {
        if (window.AudioContext || window.webkitAudioContext) {
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
      } catch (e) {
        console.error("AudioContext not supported or could not be created.", e);
        state.soundEnabled = false; // Disable sound if context fails
        soundToggle.classList.add('muted');
        soundToggle.innerHTML = '<span aria-hidden="true">🔇</span>';
        soundToggle.disabled = true; // Disable the button
      }
    }

    // サウンド再生
    function playSound(frequency = 440, duration = 50, type = 'sine') {
      if (!state.soundEnabled || !audioContext) return;

      // Ensure AudioContext is running (it might be suspended initially)
      if (audioContext.state === 'suspended') {
        audioContext.resume().catch(err => console.error("AudioContext resume failed:", err));
      }
      // If still not running, can't play sound
      if (audioContext.state !== 'running') return;

      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();

      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);

      oscillator.type = type;
      oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
      gainNode.gain.setValueAtTime(0.1, audioContext.currentTime); // Start with some volume
      gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration / 1000); // Fade out

      oscillator.start(audioContext.currentTime);
      oscillator.stop(audioContext.currentTime + duration / 1000);
    }
    
    function vibrate(pattern = [10]) {
      if (state.hapticEnabled && navigator.vibrate) {
        try {
          navigator.vibrate(pattern);
        } catch (e) {
          // Some browsers might restrict vibrate, e.g. if not from a secure context or a user gesture.
          console.warn("Vibration failed:", e);
        }
      }
    }

    function createParticle(x, y) {
      if (!state.particleEnabled) return;
      const particle = document.createElement('div');
      particle.className = 'particle';
      particle.style.left = x + 'px';
      particle.style.top = y + 'px';
      particle.style.setProperty('--tx', (Math.random() - 0.5) * 100 + 'px');
      particle.style.setProperty('--ty', (Math.random() - 0.5) * 100 + 'px');
      document.body.appendChild(particle);
      setTimeout(() => particle.remove(), 1000);
    }

    function handleButtonClick(e) {
      // Initialize audio on first user interaction if not already done
      if (!audioContext && state.soundEnabled) initializeAudio();

      const button = e.currentTarget;
      const { action, value } = button.dataset;
      const rect = button.getBoundingClientRect();
      
      vibrate();
      playSound(action === 'number' ? 300 : (action === 'clear' || action === 'backspace' ? 200 : 400));
      createParticle(rect.left + rect.width / 2, rect.top + rect.height / 2);

      if (state.errorState && action !== 'clear') {
        return; // Only allow clear if in error state
      }

      switch (action) {
        case 'number': inputDigit(value); break;
        case 'operator': handleOperator(value); break;
        case 'equals': calculate(); break;
        case 'clear': clearAll(); break;
        case 'backspace': backspace(); break;
        case 'decimal': inputDecimal(); break;
        case 'percent': inputPercent(); break;
        // default: // No default needed
      }
      updateDisplay();
    }

    function handleKeyPress(e) {
      if (!audioContext && state.soundEnabled) initializeAudio();
      
      if (state.errorState && e.key !== 'Escape' && e.key.toLowerCase() !== 'c') {
        return;
      }

      if (e.key >= '0' && e.key <= '9') { inputDigit(e.key); }
      else if (e.key === '.') { inputDecimal(); }
      else if (e.key === '+') { handleOperator('+'); }
      else if (e.key === '-') { handleOperator('-'); }
      else if (e.key === '*') { handleOperator('×'); }
      else if (e.key === '/') { e.preventDefault(); handleOperator('÷'); }
      else if (e.key === 'Enter' || e.key === '=') { e.preventDefault(); calculate(); }
      else if (e.key === 'Escape' || e.key.toLowerCase() === 'c') { clearAll(); }
      else if (e.key === 'Backspace') { backspace(); }
      else if (e.key === '%') { inputPercent(); }
      else { return; } // Don't update display if no relevant key was pressed
      
      updateDisplay();
    }

    function inputDigit(digit) {
      if (state.waitingForOperand) {
        state.displayValue = digit;
        state.waitingForOperand = false;
      } else {
        state.displayValue = state.displayValue === '0' ? digit : state.displayValue + digit;
      }
      // Limit overall length (numbers + sign + decimal)
      if (state.displayValue.length > MAX_INPUT_LENGTH + (state.displayValue.includes('.') ? 1 : 0) ) { // Allow one more for decimal
         state.displayValue = state.displayValue.slice(0, state.displayValue.length -1);
      }
    }

    function inputDecimal() {
      if (state.waitingForOperand) {
        state.displayValue = '0.';
        state.waitingForOperand = false;
        return;
      }
      if (!state.displayValue.includes('.')) {
        state.displayValue += '.';
      }
    }
    
    function backspace() {
      if (state.displayValue.length === 1 || (state.displayValue.length === 2 && state.displayValue.startsWith('-'))) {
        state.displayValue = '0';
      } else {
        state.displayValue = state.displayValue.slice(0, -1);
      }
    }

    function handleOperator(nextOperator) {
      const inputValue = parseFloat(state.displayValue);
      if (isNaN(inputValue)) return; // Should not happen if errorState is handled

      if (state.operator && state.waitingForOperand) { // Change operator
        state.operator = nextOperator;
        return;
      }

      if (state.firstOperand === null) {
        state.firstOperand = inputValue;
      } else if (state.operator) {
        const result = performCalculation[state.operator](state.firstOperand, inputValue);
        if (!isFinite(result) || isNaN(result)) {
          showError();
          return;
        }
        state.displayValue = formatResult(result);
        state.firstOperand = parseFloat(state.displayValue); // Use the formatted (and possibly clipped) result
      }
      state.waitingForOperand = true;
      state.operator = nextOperator;
    }

    function calculate() {
      if (state.firstOperand === null || !state.operator) return;
      
      const inputValue = parseFloat(state.displayValue);
      if (isNaN(inputValue)) { // Should not happen if errorState handled
          showError();
          return;
      }

      const result = performCalculation[state.operator](state.firstOperand, inputValue);
      
      if (!isFinite(result) || isNaN(result)) {
        showError();
      } else {
        state.displayValue = formatResult(result);
        // Calculation effect
        display.classList.add('calculating');
        setTimeout(() => display.classList.remove('calculating'), 1000);
      }
      state.firstOperand = null;
      state.operator = null;
      state.waitingForOperand = true; // Ready for new input, old calculation is done
    }
    
    function formatResult(value) {
        // Attempt to show some precision for non-integers, then clip/round
        let resultStr;
        if (Math.abs(value) < 1e-7 && value !== 0) { // Very small numbers to sci notation or 0
            resultStr = value.toExponential(2);
        } else if (!Number.isInteger(value)) {
            // Limit decimal places, e.g. to fit within display constraints
            // This is a simple approach, more sophisticated formatting might be needed
            resultStr = parseFloat(value.toFixed(7)).toString(); 
        } else {
            resultStr = String(value);
        }

        // Now, check length and clip if necessary for display
        let numValue = parseFloat(resultStr); // Re-parse after potential toFixed

        if (numValue > Math.pow(10, MAX_DIGITS) -1) { // e.g. > 99999
            numValue = Math.pow(10, MAX_DIGITS) -1;
        } else if (numValue < -(Math.pow(10, MAX_DIGITS-1) -1) ) { // e.g. < -9999
            numValue = -(Math.pow(10, MAX_DIGITS-1) -1);
        }
        // Final string representation
        // If it was a float that got rounded to int, remove trailing .0
        resultStr = String(numValue); 
        // Abacus works with integers, so result for abacus should be integer part
        // We can refine this: if resultStr has more chars than MAX_INPUT_LENGTH, it's an issue.
        if (resultStr.length > MAX_INPUT_LENGTH + (resultStr.includes('.') ? 1 : 0)) {
            // If still too long (e.g. very long float string even after toFixed), clip or error
            // For simplicity, clip to integer part's max length
            if (numValue > 0) resultStr = String(Math.floor(numValue)).slice(0, MAX_DIGITS);
            else resultStr = String(Math.ceil(numValue)).slice(0, MAX_INPUT_LENGTH);
        }
        return resultStr;
    }


    function showError() {
      state.displayValue = 'Error';
      state.errorState = true;
      state.firstOperand = null;
      state.operator = null;
      state.waitingForOperand = false; // Not waiting for operand, waiting for clear
      playSound(150, 200, 'square'); // Error sound
    }

    const performCalculation = {
      '÷': (a, b) => b === 0 ? Infinity : a / b,
      '×': (a, b) => a * b,
      '+': (a, b) => a + b,
      '-': (a, b) => a - b,
    };

    function inputPercent() {
        let currentValue = parseFloat(state.displayValue);
        if (isNaN(currentValue)) return;

        if (state.firstOperand !== null && state.operator) {
            // Calculate percentage of the first operand
            // e.g. 100 + 10% means 100 + (10/100 * 100)
            // e.g. 100 * 10% means 100 * (10/100)
            if (state.operator === '+' || state.operator === '-') {
                 currentValue = state.firstOperand * (currentValue / 100);
            } else { // for ×, ÷
                 currentValue = currentValue / 100;
            }
        } else {
            // Just convert current display to percentage
            currentValue = currentValue / 100;
        }
        state.displayValue = formatResult(currentValue);
        // state.waitingForOperand = true; // Depends on desired behavior after %
    }


    function clearAll() {
      state.displayValue = '0';
      state.firstOperand = null;
      state.waitingForOperand = false;
      state.operator = null;
      state.errorState = false;
      playSound(250, 100, 'sawtooth');
    }

    function updateDisplay() {
      display.textContent = state.displayValue;
      // Abacus only shows positive integers up to MAX_DIGITS
      const valueForAbacus = Math.floor(Math.abs(parseFloat(state.displayValue))) || 0;
      updateAbacus(valueForAbacus);
      display.setAttribute('aria-label', `計算結果: ${state.displayValue}`);
    }

    function updateAbacus(value) {
      document.querySelectorAll('.abacus-bead').forEach(bead => {
        bead.classList.remove('active', 'moving');
        bead.setAttribute('aria-pressed', 'false');
      });

      if (value > Math.pow(10, MAX_DIGITS) -1 ) value = Math.pow(10, MAX_DIGITS) -1; // Cap for abacus

      // Convert number to an array of digits, left-padded with '0' to MAX_DIGITS length.
      // E.g., 123 becomes ['0', '0', '1', '2', '3'] for a 5-digit abacus.
      const digits = value.toString().padStart(MAX_DIGITS, '0').split('');
      
      digits.forEach((digitStr, positionIndex) => { // positionIndex: 0 for 万, 1 for 千, ...
        const digitValue = parseInt(digitStr);
        
        const heavenBead = document.querySelector(
          `.abacus-bead.heaven[data-position-index="${positionIndex}"]`
        );
        if (digitValue >= 5) {
          if (heavenBead && !heavenBead.classList.contains('active')) {
            setTimeout(() => {
              heavenBead.classList.add('active', 'moving');
              heavenBead.setAttribute('aria-pressed', 'true');
              playSound(600, 30);
            }, positionIndex * 50);
          }
        } else {
            if (heavenBead && heavenBead.classList.contains('active')) {
                 setTimeout(() => { // Deactivate if not >= 5
                    heavenBead.classList.remove('active', 'moving');
                    heavenBead.setAttribute('aria-pressed', 'false');
                 }, positionIndex * 50);
            }
        }

        const earthValue = digitValue % 5;
        const earthBeadsInRod = document.querySelectorAll(
          `.abacus-bead.earth[data-position-index="${positionIndex}"]`
        );
        
        earthBeadsInRod.forEach((earthBead, beadIndexInRod) => { // beadIndexInRod: 0 (top) to 3 (bottom)
            // Earth beads are active if their index is less than earthValue
            // (i.e., if beadIndexInRod is 0, 1, ..., earthValue-1)
            const shouldBeActive = beadIndexInRod < earthValue;
            if (shouldBeActive && !earthBead.classList.contains('active')) {
                setTimeout(() => {
                    earthBead.classList.add('active', 'moving');
                    earthBead.setAttribute('aria-pressed', 'true');
                    playSound(400 + beadIndexInRod * 50, 30);
                }, positionIndex * 50 + (beadIndexInRod + 1) * 30);
            } else if (!shouldBeActive && earthBead.classList.contains('active')) {
                 setTimeout(() => { // Deactivate if not needed
                    earthBead.classList.remove('active', 'moving');
                    earthBead.setAttribute('aria-pressed', 'false');
                 }, positionIndex * 50 + (beadIndexInRod + 1) * 30);
            }
        });
      });
    }

    function handleBeadClick(e) {
      if (!audioContext && state.soundEnabled) initializeAudio(); // Ensure audio context for direct bead interaction
      if (state.errorState) return; // No bead interaction in error state

      const bead = e.currentTarget;
      const positionIndex = parseInt(bead.dataset.positionIndex); // 0 for 万 ... 4 for 一
      const wasActive = bead.classList.contains('active');
      
      vibrate();
      // Sound pitch depends on whether activating or deactivating
      playSound(wasActive ? 350 : 550, 40, 'triangle');
      bead.classList.toggle('active');
      bead.classList.add('moving'); // Add moving class for animation
      bead.setAttribute('aria-pressed', String(!wasActive));

      if (bead.classList.contains('earth')) {
        // Standard abacus behavior for earth beads:
        // - Clicking an inactive bead to activate it also activates beads below it (further from divider).
        // - Clicking an active bead to deactivate it also deactivates beads above it (closer to divider).
        // This means we operate on a "stack" from the clicked bead.
        // data-index is 0 (top) to 3 (bottom)
        const clickedEarthBeadIndex = parseInt(bead.dataset.index);
        const earthBeadsInRod = document.querySelectorAll(
            `.abacus-bead.earth[data-position-index="${positionIndex}"]`
        );

        if (!wasActive) { // Bead was off, turned on (move beads up)
            // All beads from clicked one UP TO THE TOP (index 0) should be activated
            for (let i = 0; i <= clickedEarthBeadIndex; i++) {
                if (!earthBeadsInRod[i].classList.contains('active')) {
                    earthBeadsInRod[i].classList.add('active');
                    earthBeadsInRod[i].setAttribute('aria-pressed', 'true');
                }
            }
        } else { // Bead was on, turned off (move beads down)
            // All beads from clicked one DOWN TO THE BOTTOM (index 3) should be deactivated
            for (let i = clickedEarthBeadIndex; i < 4; i++) {
                 if (earthBeadsInRod[i].classList.contains('active')) {
                    earthBeadsInRod[i].classList.remove('active');
                    earthBeadsInRod[i].setAttribute('aria-pressed', 'false');
                }
            }
        }
      }
      
      // Recalculate displayValue from abacus state
      let newDisplayValue = 0;
      for (let i = 0; i < MAX_DIGITS; i++) { // Rod index: 0 (万) to 4 (一)
        let digitOnRod = 0;
        const heavenBead = document.querySelector(`.abacus-bead.heaven[data-position-index="${i}"]`);
        if (heavenBead.classList.contains('active')) {
          digitOnRod += 5;
        }
        const earthBeadsInRod = document.querySelectorAll(`.abacus-bead.earth[data-position-index="${i}"]`);
        earthBeadsInRod.forEach(eb => {
          if (eb.classList.contains('active')) {
            digitOnRod += 1;
          }
        });
        newDisplayValue = newDisplayValue * 10 + digitOnRod;
      }
      
      state.displayValue = String(newDisplayValue);
      // Reset calculator state if abacus is manually changed
      state.firstOperand = null;
      state.operator = null;
      state.waitingForOperand = false; // Start new input if numbers are typed
      
      updateDisplay(); // This will call updateAbacus again, which is fine, it will simply re-affirm state
                       // Or, could optimize updateDisplay to not call updateAbacus if called from here.
    }


    function checkFirstVisit() {
      if (!localStorage.getItem('pikosoroVisited')) { // Changed to localStorage for persistence
        setTimeout(() => {
          tutorialOverlay.hidden = false;
          tutorialOverlay.classList.add('active');
          localStorage.setItem('pikosoroVisited', 'true');
        }, 1000);
      } else {
        tutorialOverlay.hidden = true; // Ensure it's hidden if already visited
      }
    }

    function closeTutorial() {
      tutorialOverlay.classList.remove('active');
      tutorialOverlay.hidden = true;
      vibrate([50, 50, 50]);
      // Focus management: return focus to a sensible element, e.g., first calculator button
      const firstCalcButton = document.querySelector('.calc-button[data-action="clear"]');
      if (firstCalcButton) firstCalcButton.focus();
    }

    function toggleSound() {
      if (!audioContext && !state.soundEnabled) { // If sound was off and context not init
          initializeAudio(); // Try to initialize now
      }
      state.soundEnabled = !state.soundEnabled;
      soundToggle.classList.toggle('muted', !state.soundEnabled);
      soundToggle.innerHTML = state.soundEnabled ? 
        '<span aria-hidden="true">🔊</span>' : 
        '<span aria-hidden="true">🔇</span>';
      soundToggle.setAttribute('aria-pressed', state.soundEnabled.toString());
      
      if (state.soundEnabled && audioContext) {
        playSound(440, 100);
      }
    }

    function toggleSettings() {
      const isActive = settingsPanel.classList.toggle('active');
      settingsPanel.hidden = !isActive;
      settingsButton.setAttribute('aria-expanded', isActive.toString());
      vibrate();
      if (isActive) {
        settingsPanel.querySelector('input[type="checkbox"]').focus();
      } else {
        settingsButton.focus();
      }
    }

    function initializePWA() {
      window.addEventListener('beforeinstallprompt', (e) => {
        e.preventDefault();
        deferredPrompt = e;
        setTimeout(() => {
          installPromptEl.classList.add('show');
          installPromptEl.hidden = false;
        }, 30000); // Show after 30 seconds
      });

      window.addEventListener('appinstalled', () => {
        installPromptEl.classList.remove('show');
        installPromptEl.hidden = true;
        deferredPrompt = null;
        console.log('ピコそろがインストールされました！');
      });
    }

    async function installPWA() {
      if (!deferredPrompt) return;
      installPromptEl.classList.remove('show'); // Hide prompt first
      installPromptEl.hidden = true;
      deferredPrompt.prompt();
      const { outcome } = await deferredPrompt.userChoice;
      if (outcome === 'accepted') {
        console.log('ユーザーはPWAのインストールを許可しました');
      } else {
        console.log('ユーザーはPWAのインストールを拒否しました');
      }
      deferredPrompt = null;
    }

    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./sw.js') // Changed to relative path
          .then(registration => console.log('ServiceWorker registration successful with scope: ', registration.scope))
          .catch(error => console.log('ServiceWorker registration failed: ', error));
      });
    }

    window.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>
